<html>

<head>
    <link rel="preconnect" href="https://fonts.bunny.net">
    <link rel="preconnect" href="https://fonts.bunny.net">
    <link rel="preconnect" href="https://fonts.bunny.net">
    <link href="https://fonts.bunny.net/css?family=chivo-mono:700" rel="stylesheet" />
    <style>
        body {
            font-family: 'Chivo Mono', monospace;
            background: #000;
            color: hsl(0, 100%, 77%);
            margin: 0;
            padding: 0;
            text-align: center;
            display: flex;
            flex-direction: row;
            align-items: center;


        }


        main {
            width: 100vw;
            height: 100vh;

            display: grid;
            grid-template-columns: 1fr 8fr 1fr;
            grid-template-rows: 1fr 2em 2fr 2em 1fr;
            grid-column-gap: 0px;
            grid-row-gap: 1vh;
        }

        .time-container {

            grid-area: 3 / 2 / 4 / 3;
            container-name: time-container;
            container-type: size;
            text-align: center;
        }

        @container time-container (orientation: landscape) {

            .time {

                font-size:41cqw;
                line-height: 100cqh;

            }
        }
        
        @container time-container (orientation: portrait) {
            .time {
                font-size:48cqh;
                line-height: 1em;

                span {
                    display:block;
                }
            }
        }

        .hex {
            font-size: 2em;
            line-height: 1;
            display: inline-block;
        }

        .a {
            grid-area: 2 / 2 / 3 / 3;
        }

        .b {
            grid-area: 4 / 2 / 5 / 3;
        }
    </style>
    <link rel="stylesheet" href="/css/clock-toys.css" />
    <script type="text/javascript" src="/js/clock-toys.js"></script>
</head>

<body>
    <main>

        <span class="hex a"></span>
        <div class="time-container">
            <span class="time">
                <span class="hours">12</span><span class="minutes">40</span>
            </span>
        </div>
        <span class="hex b"></span>
        <!-- <input type="range" value="0" /> -->

    </main>
    <script>

        // const elTime = document.querySelector('time');
        const elmain = document.querySelector('main');
        const elhexa = document.querySelector('.hex.a');
        const elhexb = document.querySelector('.hex.b');
        const eltime = document.querySelector('.time');
        const elhours = document.querySelector('.hours');
        const elminutes = document.querySelector('.minutes');
        // const elrange = document.querySelector('input[type=range]');
        let timer;
        let running = true;

        let colors = {
            a: { H: '', S: '', L: '' },
            b: { H: '', S: '', L: '' }
        }

        const setA = ['a', 'b', 'a', 'b'];
        const setB = ['b', 'a', 'b', 'a'];
        const offsets = [
            -50, 0, 50, 100
        ]

        const popUnshift = () => {
            // pops it off the end 'n shifts it to the start
            stops.unshift(stops.pop());
        }


        /**
         * 
         * I'm an idiot - this is excessively complex - I don't need to move the stops, I should fix them, and cycle the colors with an offset
         * 
         * Also - when the sat & lum values flip, it's quite jarring :( can we do a timing / easing function?
         * NB - It's on the hour  that you see the big jump (at least I saw it at 0959 - 1000)
         * 
         * Also - build a clock controller panel to test out different times etc.
         * 
         * Also - change sweepTime to an object for the params, so it can be extended without breaking old clocks
         * 
         * Also - create functionality for timers, long clocks (millenium hand anyone?), alarms, sounds, generative noise etc
         * 
         * Also - the timeKeys and timeVals arrays should _really_ just be an object... don't know why I'm being weird about it... or maybe an object _And_ and array... :thinking:
         * 
         * Also - I'm nuts -- WHY don't I just convert to ms immediately, do all the changes, then convert back (if nesc) to clockTime?
         */


        const tick = (ts) => {
            // const time = crudeDate(0);

            const clockTime = getClockTime();

            colors.a.H = sweepTime({dividend: 360, timeObj: clockTime, p: 'ms', m: 'm'});
            colors.a.S = sweepTime({dividend: 100, timeObj: clockTime, p: 'ms', m: 'h', bounce: true});
            // colors.a.S = 50;
            colors.a.L = sweepTime({dividend: 100, timeObj: clockTime, p: 'ms', m: 'd', bounce: true});
            // colors.a.L = 50;

            // range = sweepTime({dividend: 100, timeObj: clockTime, p: 'ms', m: 's', bounce: true});


            // colors.b.H = (colors.a.H + (360 / 2)) % 360;
            colors.b.H = Math.abs(colors.a.H - 360);
            colors.b.S = Math.abs(colors.a.S - 100);
            colors.b.L = Math.abs(colors.a.L - 100);

            const pulse = sweepTime({dividend: 100, timeObj : clockTime, p: 'ms', m: 'm'});

            let rings = [];
            let ss = [];

            let stops = pulse >= 50 ? setB : setA;

            stops.forEach((v, i) => {
                let stop = (pulse % 50) + offsets[i];
                rings.push(`hsl(${colors[v].H}, ${colors[v].S}%, ${colors[v].L}%) ${stop}%`);
                ss.push(parseInt(stop));
            })

            const aHex = hslToHex(colors.a.H, colors.a.S, colors.a.L).toUpperCase();
            const bHex = hslToHex(colors.b.H, colors.b.S, colors.b.L).toUpperCase();
            elhexa.setAttribute('style', `color: ${aHex}`); //text-shadow: 0 0 0.2em ${bHex};`)
            let {H:ah, S:as, L:al} = {...colors.a}
            // elhexa.innerHTML = `A: hsl(${parseInt(ah)}, ${parseInt(as)}, ${parseInt(al)})`;
            elhexa.innerHTML = aHex;
            elhexb.setAttribute('style', `color: ${bHex}`); //text-shadow: 0 0 0.2em ${aHex};`)
            let {H:bh, S:bs, L:bl} = {...colors.b}

            // elhexb.innerHTML = `B: hsl(${parseInt(bh)}, ${parseInt(bs)}, ${parseInt(bl)})`;;
            elhexb.innerHTML = bHex;

            // elrange.value=range;

            const clockface = `background: radial-gradient(circle, ${rings.join(', ')});`;
            elmain.setAttribute('style', clockface);
            
            eltime.setAttribute('style', `color: ${aHex}; text-shadow: 0 2vw 1vh ${bHex};`);
            elhours.innerText = String(clockTime.h).padStart(2, '0');
            elminutes.innerText = String(clockTime.m).padStart(2, '0');
            timer = requestAnimationFrame(tick);
        }

        timer = requestAnimationFrame(tick);




        /// This is not ideal - should encapsulate :)
        cpInit({
            is24hour : true,
        });

        elmain.addEventListener("dblclick", () => {
            console.log('running', !controlPanel.isOpen());
            if (!controlPanel.isOpen()) {


                // probably don't (now) want to cancel the animation frame, just the time function.
                // cancelAnimationFrame(timer);
                toggleControlPanel(true);
            } else {
                // timer = requestAnimationFrame(tick);
                toggleControlPanel(false);
            }
        });


        
    </script>
</body>

</html>